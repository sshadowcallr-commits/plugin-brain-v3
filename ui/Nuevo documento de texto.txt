# ui/main_gui.py
import os, json, threading, time, traceback, hashlib, re
from queue import Queue, Empty
from pathlib import Path
import customtkinter as ctk
from tkinter import ttk, messagebox, simpledialog, Menu, END

# optional psutil for system stats
try:
    import psutil
except Exception:
    psutil = None

from core.agents import ScannerAgent, ClassifierAgent, CognitiveBrainAgent, FileManagerAgent, SeederAgent

LOGS_DIR = Path("logs"); LOGS_DIR.mkdir(exist_ok=True)

def _sha256_file(path: str) -> str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()

class JSONTree:
    def __init__(self, treeview: ttk.Treeview):
        self.tree = treeview
        self._id = 0
    def _next_id(self): self._id += 1; return f"j{self._id}"
    def clear(self):
        for i in self.tree.get_children(): self.tree.delete(i)
        self._id = 0
    def load(self, data, root_text="root"):
        self.clear(); self._insert_node("", root_text, data)
    def _insert_node(self, parent, key, value):
        node_id = self._next_id()
        display = key if key is not None else "<root>"
        if isinstance(value, dict):
            self.tree.insert(parent, "end", node_id, text=f"{display} (object)")
            for k,v in value.items(): self._insert_node(node_id, k, v)
        elif isinstance(value, list):
            self.tree.insert(parent, "end", node_id, text=f"{display} (array[{len(value)}])")
            for idx,item in enumerate(value): self._insert_node(node_id, f"[{idx}]", item)
        else:
            self.tree.insert(parent, "end", node_id, text=f"{display}: {repr(value)}")

class PluginBrainApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Plugin Brain v5.0 ‚Äî Local Build")
        self.geometry("1500x860")
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("dark-blue")

        # agents & state
        self.scanner = ScannerAgent()
        self.classifier = ClassifierAgent()
        self.brain = CognitiveBrainAgent()
        self.seeder = SeederAgent()
        self.file_manager = None

        self.config = self._load_config()
        self.preview_data = {}  # src_path -> record
        self.ui_queue = Queue()
        self.worker = None
        self.stop_event = threading.Event()

        self._build_ui()
        self.after(100, self._process_ui_queue)
        self.after(1000, self._update_system_stats)

        # seed rules (non-blocking)
        threading.Thread(target=self._run_seeder, daemon=True).start()

    def _run_seeder(self):
        try:
            self.seeder.run()
            # load seeder rules into classifier (if any)
            self.classifier.rules.update(self.seeder.rules)
            self.log("SYSTEM", f"Seeder loaded {len(self.seeder.rules)} rules.")
        except Exception as e:
            self.log("WARN", f"Seeder failed: {e}")

    def _load_config(self):
        cfg_path = Path("config.json")
        if not cfg_path.exists():
            return {}
        try:
            return json.loads(cfg_path.read_text(encoding="utf-8"))
        except Exception:
            return {}

    def _save_config(self):
        cfg = self.config
        cfg["installed_path"] = self.installed_entry.get().strip()
        cfg["target_root"] = self.target_entry.get().strip()
        Path("config.json").write_text(json.dumps(cfg, indent=2), encoding="utf-8")
        self.log("SYSTEM", "Config saved.")

    def _build_ui(self):
        # top controls
        top = ctk.CTkFrame(self)
        top.grid(row=0, column=0, sticky="ew", padx=10, pady=8)
        top.grid_columnconfigure(1, weight=1)

        ctk.CTkLabel(top, text="Installed:").grid(row=0, column=0, sticky="w", padx=6)
        self.installed_entry = ctk.CTkEntry(top, height=28)
        self.installed_entry.grid(row=0, column=1, sticky="ew", padx=6)
        self.installed_entry.insert(0, self.config.get("installed_path",""))

        ctk.CTkLabel(top, text="Target Root:").grid(row=1, column=0, sticky="w", padx=6)
        self.target_entry = ctk.CTkEntry(top, height=28)
        self.target_entry.grid(row=1, column=1, sticky="ew", padx=6)
        self.target_entry.insert(0, self.config.get("target_root",""))

        self.scan_btn = ctk.CTkButton(top, text="Scan & Auto-Classify", command=self.start_scan, height=44)
        self.scan_btn.grid(row=0, column=2, rowspan=2, padx=8)

        self.load_installed_btn = ctk.CTkButton(top, text="Load Editor", command=self.load_installed_into_editor, height=30)
        self.load_installed_btn.grid(row=0, column=3, padx=6)
        self.bulk_btn = ctk.CTkButton(top, text="Bulk Move Above Threshold", command=self.bulk_move_above_threshold, height=30)
        self.bulk_btn.grid(row=1, column=3, padx=6)

        # main split: left debug, right tabs
        main = ctk.CTkFrame(self)
        main.grid(row=1, column=0, sticky="nsew", padx=10, pady=8)
        main.grid_rowconfigure(0, weight=1); main.grid_columnconfigure(1, weight=1)

        # left debug pane
        left = ctk.CTkFrame(main, width=380)
        left.grid(row=0, column=0, sticky="nsw", padx=(0,8))
        left.grid_rowconfigure(3, weight=1)

        ctk.CTkLabel(left, text="üêõ Debug Trace").grid(row=0, column=0, sticky="w", padx=8, pady=(6,2))
        self.trace_box = ctk.CTkTextbox(left, height=160, font=("Consolas",10))
        self.trace_box.grid(row=1, column=0, sticky="nsew", padx=8, pady=(0,8))
        ctk.CTkLabel(left, text="JSON Inspector").grid(row=2, column=0, sticky="w", padx=8, pady=(2,2))
        self.json_tree = ttk.Treeview(left)
        self.json_tree.grid(row=3, column=0, sticky="nsew", padx=8, pady=6)
        self.json_inspector = JSONTree(self.json_tree)

        # right tabs
        right = ctk.CTkFrame(main)
        right.grid(row=0, column=1, sticky="nsew")
        right.grid_rowconfigure(0, weight=1); right.grid_columnconfigure(0, weight=1)

        self.tabview = ctk.CTkTabview(right)
        self.tabview.pack(expand=True, fill="both")
        self.tabview.add("Pipeline"); self.tabview.add("Editor"); self.tabview.add("Inspector")

        # Pipeline tab
        ptab = self.tabview.tab("Pipeline")
        ptab.grid_columnconfigure(0, weight=1); ptab.grid_rowconfigure(0, weight=1)
        self.logbox = ctk.CTkTextbox(ptab, font=("Consolas",11))
        self.logbox.grid(row=0, column=0, sticky="nsew", padx=6, pady=6)

        # Editor tab
        etab = self.tabview.tab("Editor")
        etab.grid_columnconfigure(0, weight=1); etab.grid_rowconfigure(1, weight=1)
        search_frame = ctk.CTkFrame(etab)
        search_frame.grid(row=0, column=0, sticky="ew", pady=(6,0))
        self.search_var = ctk.StringVar()
        self.search_var.trace_add("write", lambda *a: self._filter_preview())
        ctk.CTkEntry(search_frame, textvariable=self.search_var, placeholder_text="Search plugins...").pack(side="left", fill="x", expand=True, padx=6)

        self.preview_cols = ("status","plugin","variant","vendor","confidence","suggested_path")
        style = ttk.Style(); style.theme_use("clam"); style.configure("Treeview", rowheight=26)
        self.tree = ttk.Treeview(etab, columns=self.preview_cols, show="headings", selectmode="browse")
        for c in self.preview_cols:
            self.tree.heading(c, text=c.replace("_"," ").title()); self.tree.column(c, width=140, anchor="w")
        self.tree.column("suggested_path", width=420)
        self.tree.grid(row=1, column=0, sticky="nsew", padx=6, pady=(0,6))
        self.tree.bind("<Double-1>", self._on_double_click)
        self.menu = Menu(self.tree, tearoff=0)
        self.menu.add_command(label="Apply Correction (Move)", command=self._on_apply_move)
        self.menu.add_command(label="Reclassify with Brain", command=self._on_reclassify)
        self.tree.bind("<Button-3>", self._on_right_click)

        # Inspector tab (big JSON)
        itab = self.tabview.tab("Inspector")
        itab.grid_columnconfigure(0, weight=1); itab.grid_rowconfigure(0, weight=1)
        self.inspector_tree = ttk.Treeview(itab)
        self.inspector_tree.grid(row=0, column=0, sticky="nsew", padx=6, pady=6)
        self.inspector_json = JSONTree(self.inspector_tree)

        # status bar
        status = ctk.CTkFrame(self, fg_color="#0f1114", height=36)
        status.grid(row=2, column=0, sticky="ew", padx=0, pady=(4,8))
        status.grid_columnconfigure(3, weight=1)
        self.cpu_label = ctk.CTkLabel(status, text="CPU: N/A"); self.cpu_label.grid(row=0, column=0, padx=8)
        self.mem_label = ctk.CTkLabel(status, text="MEM: N/A"); self.mem_label.grid(row=0, column=1, padx=8)
        self.progress = ctk.CTkProgressBar(status, width=400); self.progress.grid(row=0, column=2, padx=8)
        self.status_label = ctk.CTkLabel(status, text="Ready."); self.status_label.grid(row=0, column=3, padx=8, sticky="e")

    # ---------- system stats ----------
    def _update_system_stats(self):
        try:
            if psutil:
                cpu = psutil.cpu_percent(interval=None); mem = psutil.virtual_memory().percent
                self._enqueue_ui(lambda: self.cpu_label.configure(text=f"CPU: {cpu:.0f}%"))
                self._enqueue_ui(lambda: self.mem_label.configure(text=f"MEM: {mem:.0f}%"))
        except Exception:
            pass
        self.after(1000, self._update_system_stats)

    # ---------- scanning & pipeline ----------
    def start_scan(self):
        # auto-classify all discovered plugins
        self._save_config()
        installed = self.installed_entry.get().strip()
        target = self.target_entry.get().strip()
        if not installed or not target:
            messagebox.showerror("Paths required", "Set both Installed and Target Root paths.")
            return
        self.file_manager = FileManagerAgent(target)
        self.stop_event.clear()
        self.worker = threading.Thread(target=self._worker_scan, args=(installed,target), daemon=True)
        self.worker.start()
        self.tabview.set("Pipeline")

    def _worker_scan(self, installed, target):
        self._enqueue_ui(lambda: self.scan_btn.configure(state="disabled", text="Running..."))
        try:
            plugins = self.scanner.find_plugins(installed)
            total = len(plugins)
            if total == 0:
                self.log("PIPELINE", "No plugins found.")
                return
            manifest_updates = {}
            for i,p in enumerate(plugins):
                if self.stop_event.is_set():
                    self.log("PIPELINE", "Stop requested.")
                    break
                self._enqueue_ui(lambda v=(i+1)/total: self.progress.set(v))
                self._enqueue_ui(lambda s=f"Processing {p['base_name']}...": self.status_label.configure(text=s))

                # classifier suggestion
                suggestion = self.classifier.suggest(p['base_name'])
                # reasoning
                decision = self.brain.reason(p['base_name'], p.get('variant', []), f"VendorHint:{p.get('vendor_hint','')}")
                # append trace + inspector
                trace = {"plugin": p, "suggestion": suggestion, "decision": decision, "idx": i+1, "total": total, "ts": time.time()}
                self._enqueue_ui(lambda t=trace: self._append_trace_and_inspect(t))

                path = decision.get('path') or []
                if path and len(path) == 5:
                    # move/copy into target structure (we copy original into final path)
                    try:
                        dst = self.file_manager.copy(p['path'], path)
                        manifest_updates[os.path.basename(p['path'])] = {"path": dst}
                        self.log("SUCCESS", f"Copied {p['base_name']} -> {'/'.join(path)}")
                    except Exception as e:
                        self.log("ERR", f"I/O copy failed: {e}")
                        audit = ["Effects","NEEDS_REVIEW","I/O Error", p.get('vendor_hint','Unknown'), p['base_name']]
                        dst = self.file_manager.copy(p['path'], audit)
                        manifest_updates[os.path.basename(p['path'])] = {"path": dst}
                else:
                    self.log("AUDIT", f"Needs review: {p['base_name']}")
                    audit = ["Effects","NEEDS_REVIEW","BrainFailure", p.get('vendor_hint','Unknown'), p['base_name']]
                    dst = self.file_manager.copy(p['path'], audit)
                    manifest_updates[os.path.basename(p['path'])] = {"path": dst}

            # update manifest
            self.scanner.update_manifest(target, manifest_updates)
            self.log("PIPELINE", "Scan finished.")
        except Exception:
            self.log("FATAL", traceback.format_exc())
        finally:
            self._enqueue_ui(lambda: self.scan_btn.configure(state="normal", text="Scan & Auto-Classify"))
            self._enqueue_ui(lambda: self.progress.set(1.0))
            self._enqueue_ui(lambda: self.status_label.configure(text="Ready"))

    # ---------- trace & inspector ----------
    def _append_trace_and_inspect(self, trace: dict):
        p = trace["plugin"]
        dec = trace["decision"]
        line = f"[{time.strftime('%H:%M:%S')}] {p['base_name']} c={dec.get('confidence',0):.2f}"
        try:
            self.trace_box.insert(END, line + "\n")
            self.trace_box.see(END)
        except Exception:
            pass
        # load into inspector
        try:
            data = {"plugin": p, "suggestion": trace.get("suggestion"), "decision": dec}
            self.json_inspector.load(data, root_text=p['base_name'])
            self.inspector_json.load(data, root_text=p['base_name'])
        except Exception:
            pass

    # ---------- editor / preview ----------
    def load_installed_into_editor(self):
        self._save_config()
        installed = self.installed_entry.get().strip()
        if not installed:
            messagebox.showerror("Missing path", "Set Installed path first.")
            return
        items = self.scanner.find_plugins(installed)
        self.preview_data.clear()
        for p in items:
            self.preview_data[p['path']] = {
                "status":"new", "plugin": p['base_name'], "variant": ",".join(p.get('variant',[])),
                "vendor": p.get('vendor_hint',''), "confidence": 0.0, "suggested_path":""
            }
        self._refresh_tree()
        self.tabview.set("Editor")
        self.log("SYSTEM", f"Editor loaded {len(self.preview_data)} items.")

    def _refresh_tree(self):
        for r in self.tree.get_children(): self.tree.delete(r)
        for src,rec in self.preview_data.items():
            vals = [rec.get(k,"") for k in self.preview_cols]
            self.tree.insert("", "end", iid=src, values=vals)
        self._highlight_low_confidence()

    def _filter_preview(self):
        q = self.search_var.get().strip().lower()
        for iid in self.tree.get_children():
            vals = " ".join(str(x).lower() for x in self.tree.item(iid)["values"])
            if q and q not in vals:
                self.tree.detach(iid)
            else:
                try: self.tree.reattach(iid, "", "end")
                except Exception: pass

    def _highlight_low_confidence(self):
        thr = float(self.config.get("classifier_threshold", 0.4))
        for iid in self.tree.get_children():
            vals = self.tree.item(iid)["values"]
            try: conf = float(vals[self.preview_cols.index("confidence")])
            except: conf = 0.0
            if conf < thr:
                self.tree.item(iid, tags=("low",))
            else:
                self.tree.item(iid, tags=())
        self.tree.tag_configure("low", background="#3a2b2b")

    def _on_double_click(self, event):
        iid = self.tree.focus()
        if not iid: return
        vals = list(self.tree.item(iid)["values"])
        cur = vals[self.preview_cols.index("suggested_path")]
        new = simpledialog.askstring("Edit Path", "Edit target path (use \\ to separate levels):", initialvalue=cur, parent=self)
        if new is None: return
        new = new.replace("/", "\\")
        vals[self.preview_cols.index("suggested_path")] = new
        vals[self.preview_cols.index("status")] = "edited"
        self.tree.item(iid, values=vals)
        # update preview_data
        rec = self.preview_data.get(iid)
        if rec:
            rec["suggested_path"] = new; rec["status"]="edited"

    def _on_right_click(self, event):
        iid = self.tree.identify_row(event.y)
        if iid:
            self.tree.selection_set(iid)
            self.menu.tk_popup(event.x_root, event.y_root)

    def _on_apply_move(self):
        iid = self.tree.focus()
        if not iid:
            messagebox.showinfo("Select", "Select a plugin first.")
            return
        vals = list(self.tree.item(iid)["values"])
        plugin_name = vals[self.preview_cols.index("plugin")]
        suggested = vals[self.preview_cols.index("suggested_path")]
        if not suggested:
            messagebox.showerror("No path", "No suggested path present. Edit first or reclassify.")
            return
        src_path = iid
        if not messagebox.askyesno("Confirm Move", f"Move {plugin_name} to {suggested}? This will MOVE the file."):
            return
        rel = [p for p in re.split(r"[\\\\/]+", suggested) if p]
        try:
            if self.file_manager is None:
                self.file_manager = FileManagerAgent(self.target_entry.get().strip())
            res = self.file_manager.move_to_target(src_path, rel)
            dst = res.get("dst") if isinstance(res, dict) else res
            self.log("MOVE", f"{plugin_name} moved -> {dst}")
            # audit log write
            rec = {"ts": time.time(), "action":"move", "src": src_path, "dst": dst, "reason":"user_edit", "sha256": _sha256_file(src_path) if os.path.exists(src_path) else None}
            Path(LOGS_DIR, "actions.log").write_text(json.dumps(rec, ensure_ascii=False)+"\n", encoding="utf-8", append=False)
            # remove from preview
            if src_path in self.preview_data: del self.preview_data[src_path]
            self._refresh_tree()
            # reflex learn
            if hasattr(self.classifier, "upsert_reflex_sample"):
                try:
                    self.classifier.upsert_reflex_sample(plugin_name, rel)
                    self.log("LEARN", f"Reflex upserted for {plugin_name}")
                except Exception as e:
                    self.log("WARN", f"Reflex upsert failed: {e}")
        except Exception as e:
            self.log("ERR", f"Move failed: {e}")
            messagebox.showerror("Move failed", str(e))

    def bulk_move_above_threshold(self):
        thr = float(self.config.get("auto_apply_confidence", 0.9))
        to_move = []
        for src,rec in list(self.preview_data.items()):
            try: conf = float(rec.get("confidence",0) or 0)
            except: conf = 0
            if conf >= thr and rec.get("suggested_path"):
                to_move.append((src,rec))
        if not to_move:
            messagebox.showinfo("Bulk Move", "No items above threshold.")
            return
        if not messagebox.askyesno("Bulk Move", f"Move {len(to_move)} files now?"):
            return
        moved = 0
        for src,rec in to_move:
            rel = [p for p in re.split(r"[\\\\/]+", rec["suggested_path"]) if p]
            try:
                if self.file_manager is None:
                    self.file_manager = FileManagerAgent(self.target_entry.get().strip())
                res = self.file_manager.move_to_target(src, rel)
                dst = res.get("dst") if isinstance(res, dict) else res
                self.log("MOVE", f"{rec['plugin']} moved -> {dst}")
                moved += 1
                del self.preview_data[src]
            except Exception as e:
                self.log("ERR", f"Bulk move failed for {rec['plugin']}: {e}")
        self._refresh_tree()
        self.log("SYSTEM", f"Bulk move completed: {moved} files moved.")

    # ---------- reclassify (manual) ----------
    def _on_reclassify(self):
        iid = self.tree.focus()
        if not iid:
            messagebox.showinfo("Select", "Select a plugin first.")
            return
        plugin_name = self.tree.item(iid)["values"][self.preview_cols.index("plugin")]
        self.log("BRAIN", f"Manual reclassify requested: {plugin_name}")
        try:
            decision = self.brain.reason(plugin_name, [], f"Manual reclassify for {plugin_name}")
            self._enqueue_ui(lambda d=decision: self.json_inspector.load({"plugin":plugin_name,"decision":d}, root_text=plugin_name))
            self.log("BRAIN", f"Reclassify done (c={decision.get('confidence',0):.3f})")
        except Exception as e:
            self.log("ERR", f"Reclassify failed: {e}")

    # ---------- logging / UI queue ----------
    def log(self, level, msg):
        self._enqueue_ui(lambda: self.logbox.insert(END, f"[{level:<8}] {msg}\n"))
        self._enqueue_ui(lambda: self.logbox.see(END))
        if level in ("JOB","BRAIN","SUCCESS","AUDIT","ERR","FATAL","MOVE","PIPELINE"):
            self._enqueue_ui(lambda: self.trace_box.insert(END, f"[{level}] {msg}\n"))
            self._enqueue_ui(lambda: self.trace_box.see(END))

    def _enqueue_ui(self, fn):
        self.ui_queue.put(fn)

    def _process_ui_queue(self):
        try:
            while True:
                fn = self.ui_queue.get_nowait()
                try:
                    fn()
                except Exception:
                    traceback.print_exc()
        except Empty:
            pass
        self.after(100, self._process_ui_queue)
